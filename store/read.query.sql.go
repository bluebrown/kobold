// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: read.query.sql

package store

import (
	"context"
	"strings"

	dbutil "github.com/bluebrown/kobold/dbutil"
	git "github.com/bluebrown/kobold/git"
	null "github.com/volatiletech/null/v8"
)

const channelGet = `-- name: ChannelGet :one
select name, decoder_name from channel where name = ?
`

// ChannelGet
//
//	select name, decoder_name from channel where name = ?
func (q *Queries) ChannelGet(ctx context.Context, name string) (Channel, error) {
	row := q.db.QueryRowContext(ctx, channelGet, name)
	var i Channel
	err := row.Scan(&i.Name, &i.DecoderName)
	return i, err
}

const channelList = `-- name: ChannelList :many
select name, decoder_name from channel
`

// ChannelList
//
//	select name, decoder_name from channel
func (q *Queries) ChannelList(ctx context.Context) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, channelList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Channel{}
	for rows.Next() {
		var i Channel
		if err := rows.Scan(&i.Name, &i.DecoderName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const decoderGet = `-- name: DecoderGet :one
select name, script from decoder where name = ?
`

// DecoderGet
//
//	select name, script from decoder where name = ?
func (q *Queries) DecoderGet(ctx context.Context, name string) (Decoder, error) {
	row := q.db.QueryRowContext(ctx, decoderGet, name)
	var i Decoder
	err := row.Scan(&i.Name, &i.Script)
	return i, err
}

const decoderList = `-- name: DecoderList :many
select name, script from decoder
`

// DecoderList
//
//	select name, script from decoder
func (q *Queries) DecoderList(ctx context.Context) ([]Decoder, error) {
	rows, err := q.db.QueryContext(ctx, decoderList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Decoder{}
	for rows.Next() {
		var i Decoder
		if err := rows.Scan(&i.Name, &i.Script); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pipelineGet = `-- name: PipelineGet :one
select name, repo_uri, dest_branch, post_hook_name, channels from pipeline_list_item where name = ?
`

// PipelineGet
//
//	select name, repo_uri, dest_branch, post_hook_name, channels from pipeline_list_item where name = ?
func (q *Queries) PipelineGet(ctx context.Context, name string) (PipelineListItem, error) {
	row := q.db.QueryRowContext(ctx, pipelineGet, name)
	var i PipelineListItem
	err := row.Scan(
		&i.Name,
		&i.RepoUri,
		&i.DestBranch,
		&i.PostHookName,
		&i.Channels,
	)
	return i, err
}

const pipelineList = `-- name: PipelineList :many
select name, repo_uri, dest_branch, post_hook_name, channels from pipeline_list_item
`

// PipelineList
//
//	select name, repo_uri, dest_branch, post_hook_name, channels from pipeline_list_item
func (q *Queries) PipelineList(ctx context.Context) ([]PipelineListItem, error) {
	rows, err := q.db.QueryContext(ctx, pipelineList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PipelineListItem{}
	for rows.Next() {
		var i PipelineListItem
		if err := rows.Scan(
			&i.Name,
			&i.RepoUri,
			&i.DestBranch,
			&i.PostHookName,
			&i.Channels,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pipelineRunList = `-- name: PipelineRunList :many
select p.name, r.fingerprint, r.repo_uri, r.dest_branch, r.post_hook, r.status, r.timestamp, r.warnings, r.error, r.msgs from run r
left join pipeline p on r.repo_uri = p.repo_uri and ifnull(r.dest_branch, '') = ifnull(p.dest_branch, '')
where p.name = ?
and r.status in (/*SLICE:status*/?)
limit ? offset ?
`

type PipelineRunListParams struct {
	Name   string   `json:"name"`
	Status []string `json:"status"`
	Limit  int64    `json:"limit"`
	Offset int64    `json:"offset"`
}

type PipelineRunListRow struct {
	Name        null.String      `json:"name"`
	Fingerprint string           `json:"fingerprint"`
	RepoUri     git.PackageURI   `json:"repo_uri"`
	DestBranch  null.String      `json:"dest_branch"`
	PostHook    null.String      `json:"post_hook"`
	Status      string           `json:"status"`
	Timestamp   interface{}      `json:"timestamp"`
	Warnings    dbutil.SliceText `json:"warnings"`
	Error       interface{}      `json:"error"`
	Msgs        dbutil.SliceText `json:"msgs"`
}

// PipelineRunList
//
//	select p.name, r.fingerprint, r.repo_uri, r.dest_branch, r.post_hook, r.status, r.timestamp, r.warnings, r.error, r.msgs from run r
//	left join pipeline p on r.repo_uri = p.repo_uri and ifnull(r.dest_branch, '') = ifnull(p.dest_branch, '')
//	where p.name = ?
//	and r.status in (/*SLICE:status*/?)
//	limit ? offset ?
func (q *Queries) PipelineRunList(ctx context.Context, arg PipelineRunListParams) ([]PipelineRunListRow, error) {
	query := pipelineRunList
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Name)
	if len(arg.Status) > 0 {
		for _, v := range arg.Status {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:status*/?", strings.Repeat(",?", len(arg.Status))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:status*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PipelineRunListRow{}
	for rows.Next() {
		var i PipelineRunListRow
		if err := rows.Scan(
			&i.Name,
			&i.Fingerprint,
			&i.RepoUri,
			&i.DestBranch,
			&i.PostHook,
			&i.Status,
			&i.Timestamp,
			&i.Warnings,
			&i.Error,
			&i.Msgs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postHookGet = `-- name: PostHookGet :one
select name, script from post_hook where name = ?
`

// PostHookGet
//
//	select name, script from post_hook where name = ?
func (q *Queries) PostHookGet(ctx context.Context, name string) (PostHook, error) {
	row := q.db.QueryRowContext(ctx, postHookGet, name)
	var i PostHook
	err := row.Scan(&i.Name, &i.Script)
	return i, err
}

const postHookList = `-- name: PostHookList :many
select name, script from post_hook
`

// PostHookList
//
//	select name, script from post_hook
func (q *Queries) PostHookList(ctx context.Context) ([]PostHook, error) {
	rows, err := q.db.QueryContext(ctx, postHookList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PostHook{}
	for rows.Next() {
		var i PostHook
		if err := rows.Scan(&i.Name, &i.Script); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const runGet = `-- name: RunGet :one
select fingerprint, repo_uri, dest_branch, post_hook, status, timestamp, warnings, error, msgs from run
where fingerprint = ?
`

// RunGet
//
//	select fingerprint, repo_uri, dest_branch, post_hook, status, timestamp, warnings, error, msgs from run
//	where fingerprint = ?
func (q *Queries) RunGet(ctx context.Context, fingerprint string) (Run, error) {
	row := q.db.QueryRowContext(ctx, runGet, fingerprint)
	var i Run
	err := row.Scan(
		&i.Fingerprint,
		&i.RepoUri,
		&i.DestBranch,
		&i.PostHook,
		&i.Status,
		&i.Timestamp,
		&i.Warnings,
		&i.Error,
		&i.Msgs,
	)
	return i, err
}

const runList = `-- name: RunList :many
select fingerprint, repo_uri, dest_branch, post_hook, status, timestamp, warnings, error, msgs from run
where status in (/*SLICE:status*/?)
limit ? offset ?
`

type RunListParams struct {
	Status []string `json:"status"`
	Limit  int64    `json:"limit"`
	Offset int64    `json:"offset"`
}

// RunList
//
//	select fingerprint, repo_uri, dest_branch, post_hook, status, timestamp, warnings, error, msgs from run
//	where status in (/*SLICE:status*/?)
//	limit ? offset ?
func (q *Queries) RunList(ctx context.Context, arg RunListParams) ([]Run, error) {
	query := runList
	var queryParams []interface{}
	if len(arg.Status) > 0 {
		for _, v := range arg.Status {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:status*/?", strings.Repeat(",?", len(arg.Status))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:status*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Run{}
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.Fingerprint,
			&i.RepoUri,
			&i.DestBranch,
			&i.PostHook,
			&i.Status,
			&i.Timestamp,
			&i.Warnings,
			&i.Error,
			&i.Msgs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskGet = `-- name: TaskGet :one
select id, msgs, repo_uri, dest_branch, post_hook_name, status, timestamp, warnings, failure_reason, task_group_fingerprint from task where id = ?
`

// TaskGet
//
//	select id, msgs, repo_uri, dest_branch, post_hook_name, status, timestamp, warnings, failure_reason, task_group_fingerprint from task where id = ?
func (q *Queries) TaskGet(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, taskGet, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Msgs,
		&i.RepoUri,
		&i.DestBranch,
		&i.PostHookName,
		&i.Status,
		&i.Timestamp,
		&i.Warnings,
		&i.FailureReason,
		&i.TaskGroupFingerprint,
	)
	return i, err
}

const taskList = `-- name: TaskList :many
select id, msgs, repo_uri, dest_branch, post_hook_name, status, timestamp, warnings, failure_reason, task_group_fingerprint from task
where status in (/*SLICE:status*/?)
order by timestamp desc
limit ? offset ?
`

type TaskListParams struct {
	Status []string `json:"status"`
	Limit  int64    `json:"limit"`
	Offset int64    `json:"offset"`
}

// TaskList
//
//	select id, msgs, repo_uri, dest_branch, post_hook_name, status, timestamp, warnings, failure_reason, task_group_fingerprint from task
//	where status in (/*SLICE:status*/?)
//	order by timestamp desc
//	limit ? offset ?
func (q *Queries) TaskList(ctx context.Context, arg TaskListParams) ([]Task, error) {
	query := taskList
	var queryParams []interface{}
	if len(arg.Status) > 0 {
		for _, v := range arg.Status {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:status*/?", strings.Repeat(",?", len(arg.Status))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:status*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Msgs,
			&i.RepoUri,
			&i.DestBranch,
			&i.PostHookName,
			&i.Status,
			&i.Timestamp,
			&i.Warnings,
			&i.FailureReason,
			&i.TaskGroupFingerprint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
